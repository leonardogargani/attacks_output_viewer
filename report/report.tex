\documentclass[11pt,a4paper]{article} 

%------------------------------------------------------------------------------
%	REQUIRED PACKAGES AND  CONFIGURATIONS
%------------------------------------------------------------------------------
% PACKAGES FOR TITLES
\usepackage{titlesec}
\usepackage{color}

% PACKAGES FOR LANGUAGE AND FONT
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage[T1]{fontenc} % Font encoding

% PACKAGES FOR IMAGES
\usepackage{graphicx}
\graphicspath{{img/}}
\usepackage{eso-pic} % For the background picture on the title page
\usepackage{subfig} % Numbered and caption subfigures using \subfloat
\usepackage{caption} % Coloured captions
\usepackage{transparent}

% STANDARD MATH PACKAGES
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{bm}
\usepackage[overload]{empheq}  % For braced-style systems of equations

% PACKAGES FOR TABLES
\usepackage{tabularx}
\usepackage{longtable} % tables that can span several pages
\usepackage{colortbl}

% PACKAGES FOR ALGORITHMS (PSEUDO-CODE)
\usepackage{algorithm}
\usepackage{algorithmic}

% PACKAGES FOR REFERENCES & BIBLIOGRAPHY
\usepackage[colorlinks=true,linkcolor=black,anchorcolor=black,citecolor=black,filecolor=black,menucolor=black,runcolor=black,urlcolor=black]{hyperref} % Adds clickable links at references
\usepackage{cleveref}
\usepackage[square, numbers, sort&compress]{natbib} % Square brackets, citing references with numbers, citations sorted by appearance in the text and compressed
\bibliographystyle{plain} % You may use a different style adapted to your field

% PACKAGES FOR THE APPENDIX
\usepackage{appendix}

% PACKAGES FOR ITEMIZE & ENUMERATES 
\usepackage{enumitem}

% OTHER PACKAGES
\usepackage{amsthm,thmtools,xcolor} % Coloured "Theorem"
\usepackage{comment} % Comment part of code
\usepackage{fancyhdr} % Fancy headers and footers
\usepackage{lipsum} % Insert dummy text
\usepackage{tcolorbox} % Create coloured boxes (e.g. the one for the key-words)

%-------------------------------------------------------------------------
%	NEW COMMANDS DEFINED
%-------------------------------------------------------------------------
\newcommand{\bea}{\begin{eqnarray}} % Shortcut for equation arrays
\newcommand{\eea}{\end{eqnarray}}
\newcommand{\e}[1]{\times 10^{#1}}  % Powers of 10 notation
\newcommand{\mathbbm}[1]{\text{\usefont{U}{bbm}{m}{n}#1}} % From mathbbm.sty
\newcommand{\pdev}[2]{\frac{\partial#1}{\partial#2}}

%----------------------------------------------------------------------------
%	ADD YOUR DEFINITIONS AND COMMANDS (be careful of existing commands)
%----------------------------------------------------------------------------

\input{config_files/config}

% -> title of your work
\renewcommand{\title}{CPA/Template attacks output viewer}
% -> author name and surname
\newcommand{\AUTHORa}{Leonardo Gargani}
\newcommand{\AUTHORb}{Olivier Wartique}
% -> MSc course
\newcommand{\course}{Computer Science and Engineering}
% -> supervisor name and surname
\newcommand{\supervisor}{Giuseppe Massari}
% IF AND ONLY IF you need to modify the co-supervisors you also have to modify the file config_files/title_page.tex (ONLY where it is marked)
\newcommand{\cosupervisor}{Michele Piccoli} % insert if any otherwise comment
% -> author ID
\newcommand{\IDa}{10569221}
\newcommand{\IDb}{10844629}
% -> academic year
\newcommand{\YEAR}{2021-2022}
% -> abstract (only in English)
\renewcommand{\abstract}{The Abstract is a concise summary of the content of the thesis (single page of text) and a guide to the most important contributions included in your thesis.
The Abstract is the very last thing you write.
It should be a self-contained text and should be clear to someone who hasn't (yet) read the whole manuscript.
The Abstract should contain the answers to the main research questions that have been addressed in your thesis.
It needs to summarize the motivations and the adopted approach as well as the findings of your work and their relevance and impact.}

%-------------------------------------------------------------------------
%	BEGIN OF YOUR DOCUMENT
%-------------------------------------------------------------------------
\begin{document}

%-----------------------------------------------------------------------------
% TITLE PAGE
%-----------------------------------------------------------------------------
% This file creates the Title Page of the document
\input{config_files/title_page}

%-----------------------------------------------------------------------------
% INTRODUCTION
%-----------------------------------------------------------------------------
\section{Introduction}
\label{sec:introduction}
...

%-----------------------------------------------------------------------------
% IMPLEMENTATION
%-----------------------------------------------------------------------------
\section{Implementation}
\label{sec:implementation}
\subsection{Libraries used}
The implementation is mainly build around existing libraries. Data handling and mathematical operations (such as peak detection) are carried out by \texttt{NumPy}, a fundamental package for scientific computing in Python. The GUI is build from \texttt{PyQt5} which is the Python equivalent of the C++ Qt framework. It uses a slot mechanism to communicate between items and make the software easily re-usable. Finally the plotting is using \texttt{PyQtGraph} which a data visualisation package build from \texttt{PyQt}. 

\subsection{Required input files}
The input files are stored in the \texttt{data/input/csv} folder. Each file is representing one the 16 bytes. The format of the files is a two dimensional array where the rows are the time instants (up to a few thousands rows) and the columns are the correlation values (256 columns). The values are in the range $[-1, 1]$ and separated by a coma and are representing correlations values. These are useful to determine the success of an attack.

\subsection{Pre-processing steps}
Before running the main script for the first time, it is necessary to execute two pre-processing steps in this specific order:
\begin{enumerate}
    \item \texttt{csv\_to\_npy\_conversion.py}, this script is converting the \texttt{csv} files to \texttt{npy}. This is carried out by a built-in function of the \texttt{NumPy} package. The \texttt{npy} format is the standard binary file format in \texttt{NumPy} to save a single arbitrary \texttt{NumPy} array on disk. The format stores all of the shape and dtype information necessary to reconstruct the array correctly even on another machine with a different architecture.
    \item \texttt{peak\_detection.py}, this script is executed once the \texttt{npy} files are generated. The aim of this step is to detect the peak value of each byte. The sample number of the peak value, the peak value and the byte value (i.e. column number in the corresponding \texttt{csv} file) are stored and written to a dedicated file (\texttt{data/output/csv/peaks.csv}) which is then used in the main program.
\end{enumerate}

\subsection{Implemented features}
\subsubsection{Mouse hover}
The movement of the mouse cursor is generating signals (emitted by built-in slots of \texttt{PyQt} and \texttt{PyQtGraph}). This signal is connected to callback function written by us. The position of the mouse is caught by the callback and mapped from pixels coordinates to the plot coordinates. These values are then printed on the graph window to help the user in the data visualisation and a crosshair symbol is plotted to show the cursor position on the graph widget.

\subsubsection{Signal generation}
If the user wants to study a specific value, he has the possibility to left-click on the data point. This will automatically emit a custom signal named \texttt{message} with 3 arguments: \texttt{x, y, line}. The argument \texttt{x} is an \texttt{int} corresponding to the sample number, \texttt{y} is a \texttt{float} corresponding to the correlation values and \texttt{line} is a \texttt{str} with the number of the line (i.e. column number in the corresponding \texttt{csv} file). The user can use this emitted signal and implement his own callback function with the features he wants. Currently, as a proof of concept, this signal is caught and the informations are simply printed to the console.

\subsubsection{Zoom features}
The user can zoom using different commands. Scrolling up and down is zooming and de-zooming the whole plot centered on the cursor position. Holding the right click pressed and dragging horizontally is (de-)zooming the x axis. A similar behaviour on the y axis is achieved by dragging the right click vertically. The final possibility to zoom is to right click once anywhere on the plot and select \texttt{Mouse Mode > 1 button} from the contextual menu. Then dragging with the left click is selecting a rectangular region and zooming to fit that region of interest to the window.

\subsection{Separate the logic from the GUI}
An effort was made to use as much as possible \texttt{ui} files generated by \texttt{QtCreator} which is an IDE to create applications. 

\subsection{Nice to have improvements}
Some safety measures are implemented in order to guarantee the right course of actions of the application. Our implementation makes an extensive use of file (both for reading and writing data). If by any chances one of the file is not in the correct folder or not present at all, an error message is printed to the console and the script exits. In addition, some correlation values in the files might be corrupted. The pre-processing scripts are checking for non conform values and replace them by a correlation of zero. This is the reason why executing these pre-processing scripts are primordial and an error will be thrown if they are not run or run in the wrong order. 

%-----------------------------------------------------------------------------
% ENCOUNTERED PROBLEMS AND SOLUTIONS
%-----------------------------------------------------------------------------
\section{Faced problems and solutions}
\label{sec:faced-problems-and-solutions}

During the development of the application, we had to face up some problems, mainly due to the size of the dataset to handle.
We think it can be useful to share here some insights about our decision-making process as the developement was moving forward, and the solutions we came up with.

\subsection{The starting point}

Starting from the very beginning, our goal is plotting the content of a \texttt{.csv} file, while maintaing the possibility of moving around inside the plot (i.e., zoom-in, zoom-out, change the X-range).\\

Our initial approach was plotting all the file at once. The problem that immediately arised was that handling over 7.5 million points (every \texttt{.csv} file has about 35 thousand rows and 256 columns) was definitely too resource-demanding. That led to an evidently unusable GUI due to its poor performance, not only when moving around, but also for the loading time of the plot itself.\\

Therefore, we started experimenting looking for some possible improvements to load data into memory in an efficient way using Python.\\

\subsection{Choosing the fastest file format}

A first available option we found was converting the \texttt{.csv} file into a \texttt{.hdf5} one. \texttt{HDF5} is a file format built for fast I/O processing and storage, whose potential can be fully exploited through a handy Python library.

However, the result we obtained was still very poor and the \texttt{HDF5} option had to be discarded.\\

Since we handled all the data as \texttt{NumPy} arrays, we also came across the \texttt{.npy} file format. It is a simple format for saving \texttt{NumPy} arrays, in an optimized way, with no loss of information.
After converting the \texttt{.csv} file into a \texttt{.npy} one, we plotted it in the same way as before. The loading time was significantly lower and the usability of the GUI improved, but still far from an acceptable result.\\

\subsection{Downsampling}

Having understood that \texttt{.npy} was a far better choice over \texttt{.csv} and \texttt{.hdf5}, we decided to keep that conversion step and start tweaking around to gain as much performance as possible, this time in the \texttt{PyQtGraph} plotting process.

A special tweak worth mentioning is the way we subsample data in order to be displayed in the plot.
\texttt{PyQtGraph} provides three downsampling modes: subsample, mean, and peak.

Despite being the slowest one, we picked the last one ("peak") since it downsamples by drawing a saw wave that follows the min and max of the original data. This is the only way to make sure that the peak of our plot does not get lost while displaying the points.\\

\subsection{Plotting one curve at a time}

Back to the fact that the GUI responsiveness was far from being acceptable, we came to the conclusion that showing all the 7.5 M points at the same time was not feasible in any way.

At this point we tried to change our approach. Here was (and currently is) our new one.

Since every file contains 256 rows, and each row corresponds to a curve in the plot, we can preprocess every file and identify for it which is the peak and what row it shows up in. Then, save the results in a new file.
When the user opens a plot, now the program reads the content of such a file to display by default only the curve with the peak. In addition, each one of the other curves can be shown/hidden in the plot by using a dedicated checkbox.\\

This new approach leads to a very low loading time and to a GUI which is not only usable, but which has high performance in every zoom/scroll operation.\\

Despite the high performance increase intrinsic to the new way of displaying data, we still decided to keep the conversion step from \texttt{.csv} to \texttt{.npy}.
In fact, the same file stored as \texttt{.npy} takes more than 40\% less space on disk than if stored as \texttt{.csv}.
As we will cover in more detail in the next section, this leads to both faster loading times and lower memory usage at runtime.

%-----------------------------------------------------------------------------
% EXPERIMENTAL RESULTS
%-----------------------------------------------------------------------------
\section{Experimental results}
\label{sec:experimental-results}

Here are some useful measurements about execution time and memory usage of the program.

\subsection{Testing conditions}

All the tests have been performed on a machine with an i7-7500U CPU (dual-core @ 2.70 GHz) and 8 GB of RAM.
Keep in mind that the execution time will vary from machine to machine.

Since at the moment of writing the hardware above can be considered mid-low end, you can likely expect better results when running the scripts.\\

The 16 \texttt{.csv} input files have each one with 256 columns and about 30k rows.

\subsection{Conversion from .csv to .npy}

The preprocessing step of converting the 16 files to the \texttt{.npy} format is performed by the \texttt{csv\_to\_npy\_converter.py} script.

It runs for 2m00s while using 1.1 GB of memory.

\subsection{Peak detections}

The preprocessing step of detecting the peak value of each one of the files is performed by the \texttt{peak\_detection.py} script.

When the corresponding flag is set, in addition to detecting the peaks it also generates and saves the plots of all the files.
In such a case the total execution time is 1m55s, with a memory consumption of 550 MB.

However, by default the plots are not generated and this way the execution time is extremely reduced down to just 1s.

\subsection{Main program}

For the main program (\texttt{main.py}), we recorded the change in memory consumption by varying the number of open plots and displayed curves.

In particular, the obtained results in memory consumption are the following:
\begin{itemize}
    \item the main window uses 125 MB;
    \item every other window uses:
    \begin{itemize}
    		\item 65 MB for loading the .npy file (which is the size on disk of the file);
    		\item 5 MB for the creation of the window;
    		\item 1 MB for every displayed curve.
	\end{itemize}
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.6]{main_window.png}
    \caption{Main window of the program.}
    \label{fig:main_window}
\end{figure}

\begin{figure}[H]
    \centering
    \subfloat[Showing only the curve with the peak.\label{fig:single_curve}]{
        \includegraphics[scale=0.5]{img/single_curve.png}
    }
    \quad
    \subfloat[Showing multiple curves.\label{fig:multiple_curves}]{
        \includegraphics[scale=0.5]{img/multiple_curves.png}
    }
    \caption[]{Plot of one file.}
    \label{fig:plots}
\end{figure}

%-----------------------------------------------------------------------------
% CONCLUSIONS
%-----------------------------------------------------------------------------
\section{Conclusions}
\label{sec:conclusions}

...

%-------------------------------------------------------------------------
%	END OF YOUR DOCUMENT
%-------------------------------------------------------------------------
\end{document}
